<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warframe Vault Checker</title>
    <link rel="stylesheet" href="style.css">
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="scene-container"></div>
    <div class="dots-pattern dots-left"></div>
    <div class="dots-pattern dots-right"></div>
    
    <div id="app">
        <div class="search-container">
            <input type="text" id="searchInput" placeholder="Search relic or item..." autocomplete="off">
            <button onclick="performSearch()">Search</button>
            <div id="suggestions"></div>
        </div>
        
        <!-- Support Banner -->
        <div id="support-banner" onclick="window.open('https://buymeacoffee.com/buldidev', '_blank')">
            <img src="heart.png" alt="Support" class="support-image">
            <span class="support-text">Support me to keep the site online</span>
        </div>
        
        <div class="left-panel">
            <h3>Details</h3>
            <div id="result"></div>
        </div>
        
        <div class="center-area"></div>
        
        <div class="right-panel">
            <div class="relics-header">
                <button id="activeRelicsBtn" class="toggle-btn active" onclick="toggleRelicsView('active')">Active Relics</button>
                <button id="vaultedRelicsBtn" class="toggle-btn" onclick="toggleRelicsView('vaulted')">Vaulted Relics</button>
            </div>
            <div id="activeRelicsList"></div>
        </div>
    </div>

    <footer class="footer">
        <p>Data sourced from <a href="https://warframe.fandom.com/wiki/Void_Relic" target="_blank" rel="noopener noreferrer">Warframe Wiki</a></p>
        <p>Market prices from <a href="https://warframe.market/" target="_blank" rel="noopener noreferrer">Warframe Market</a></p>
    </footer>

    <!-- YouTube Music Player -->
    <div id="music-player">
        <div id="player-header">
            <span>MUSIC</span>
            <div class="player-controls">
                <button id="audio-toggle" onclick="toggleAudio()" title="Mute/Unmute">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                        <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                    </svg>
                </button>
                <input type="range" id="volume-slider" min="0" max="100" value="50" title="Volume">
                <button id="expand-toggle" onclick="toggleExpand()" title="Show/Hide Video">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </button>
            </div>
        </div>
        <div id="player-container" style="display: none;">
            <div id="youtube-player"></div>
        </div>
    </div>

    <script type="module">
        import { init3DScene, changeModelByTier, loadBlueprintImage } from './scene3d.js';
        init3DScene();
        
        // Rendi le funzioni disponibili globalmente
        window.changeModelByTier = changeModelByTier;
        window.loadBlueprintImage = loadBlueprintImage;
    </script>
    <script>
        let relicDatabase = {};
        let vaultedRelics = [];
        let activeRelics = [];
        let itemDatabase = {}; // Mappa item->reliquie
        let currentRelicsView = 'active'; // 'active' o 'vaulted'
        let youtubePlayer = null;
        let isMuted = localStorage.getItem('musicMuted') === 'true' || false;
        let isExpanded = localStorage.getItem('musicExpanded') === 'true' || false;
        let isPlaying = false; // Parte da false, poi diventa true quando inizia

        // YouTube API ready callback
        function onYouTubeIframeAPIReady() {
            const host = window.location.protocol + '//' + window.location.host;
            youtubePlayer = new YT.Player('youtube-player', {
                host: 'https://www.youtube.com',
                videoId: 'gUgyfUIhGQc',
                playerVars: {
                    'autoplay': 0,
                    'controls': 1,
                    'loop': 1,
                    'playlist': 'gUgyfUIhGQc',
                    'modestbranding': 1,
                    'rel': 0,
                    'origin': host,
                    'enablejsapi': 1
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        function onPlayerReady(event) {
            // Imposta volume salvato o default
            const savedVolume = localStorage.getItem('musicVolume') || '50';
            event.target.setVolume(parseInt(savedVolume));
            
            // Ripristina stato mute da localStorage e applica
            if (isMuted) {
                event.target.mute();
            }
            
            // Ripristina stato espansione
            if (isExpanded) {
                const container = document.getElementById('player-container');
                const expandButton = document.getElementById('expand-toggle');
                container.style.display = 'block';
                expandButton.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="18 15 12 9 6 15"></polyline>
                    </svg>
                `;
            }
            
            // Aspetta che la thumbnail sia caricata, poi avvia sempre automaticamente
            setTimeout(() => {
                event.target.playVideo();
            }, 1000);
        }

        function onPlayerStateChange(event) {
            // YT.PlayerState.UNSTARTED = -1, ENDED = 0, PLAYING = 1, PAUSED = 2, BUFFERING = 3, CUED = 5
            if (event.data === 1) { // Playing
                isPlaying = true;
            } else { // Paused, Cued, Unstarted, or Ended
                isPlaying = false;
                // Se il video è finito, riavvialo automaticamente
                if (event.data === 0) {
                    setTimeout(() => event.target.playVideo(), 100);
                }
            }
        }

        // Toggle video visibility
        function toggleExpand() {
            const container = document.getElementById('player-container');
            const button = document.getElementById('expand-toggle');
            isExpanded = !isExpanded;
            
            // Salva preferenza
            localStorage.setItem('musicExpanded', isExpanded);
            
            if (isExpanded) {
                container.style.display = 'block';
                button.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="18 15 12 9 6 15"></polyline>
                    </svg>
                `;
            } else {
                container.style.display = 'none';
                button.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                `;
            }
        }

        // Toggle audio mute/unmute
        function toggleAudio() {
            const button = document.getElementById('audio-toggle');
            if (youtubePlayer && youtubePlayer.isMuted !== undefined) {
                if (isMuted) {
                    youtubePlayer.unMute();
                    isMuted = false;
                    localStorage.setItem('musicMuted', 'false');
                    button.innerHTML = `
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                            <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                        </svg>
                    `;
                } else {
                    youtubePlayer.mute();
                    isMuted = true;
                    localStorage.setItem('musicMuted', 'true');
                    button.innerHTML = `
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <line x1="23" y1="9" x2="17" y2="15"></line>
                            <line x1="17" y1="9" x2="23" y2="15"></line>
                        </svg>
                    `;
                }
            }
        }
        
        // Gestione volume slider
        const volumeSlider = document.getElementById('volume-slider');
        const savedVolume = localStorage.getItem('musicVolume') || '50';
        volumeSlider.value = savedVolume;
        
        volumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value;
            if (youtubePlayer && youtubePlayer.setVolume) {
                youtubePlayer.setVolume(volume);
                localStorage.setItem('musicVolume', volume);
                
                // Se il volume è > 0 e il player era mutato, smuta automaticamente
                if (volume > 0 && isMuted) {
                    youtubePlayer.unMute();
                    isMuted = false;
                    localStorage.setItem('musicMuted', 'false');
                    const button = document.getElementById('audio-toggle');
                    button.innerHTML = `
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                            <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                        </svg>
                    `;
                }
            }
        });

        // Ripristina icona mute all'avvio
        window.addEventListener('DOMContentLoaded', () => {
            if (isMuted) {
                const button = document.getElementById('audio-toggle');
                button.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                        <line x1="23" y1="9" x2="17" y2="15"></line>
                        <line x1="17" y1="9" x2="23" y2="15"></line>
                    </svg>
                `;
            }
        });

        // Load YouTube API
        const tag = document.createElement('script');
        tag.src = 'https://www.youtube.com/iframe_api';
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        // Load data on startup
        window.addEventListener('DOMContentLoaded', async () => {
            await loadRelicData();
        });

        async function loadRelicData() {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = '<div class="loading"> Loading data from Warframe Wiki...</div>';

            try {
                // Use MediaWiki API to get raw content
                const url = 'https://warframe.fandom.com/api.php?action=query&format=json&prop=revisions&titles=Module:Void/data&rvprop=content&rvslots=main&origin=*';
                
                const response = await fetch(url);
                const data = await response.json();
                
                const pages = data.query.pages;
                const pageId = Object.keys(pages)[0];
                const content = pages[pageId].revisions[0].slots.main['*'];
                                
                // Parse Lua content
                parseRelicData(content);
                
                resultDiv.innerHTML = '';
                displayActiveRelics();
                
            } catch (error) {
                resultDiv.innerHTML = `<div class="error">Loading error: ${error.message}</div>`;
                console.error(error);
            }
        }

        function parseRelicData(luaContent) {
            // Trova RelicData usando regex
            const relicDataRegex = /RelicData\s*=\s*\{([\s\S]*?)\n\}\n/;
            const match = luaContent.match(relicDataRegex);
            
            if (!match) {
                throw new Error('RelicData not found');
            }
            
            const relicSection = match[1];

            // Pattern to match each complete relic
            const relicRegex = /\["([^"]+)"\]\s*=\s*\{([\s\S]*?)\n\t\},?/g;
            let relicMatch;
            let count = 0;
            
            while ((relicMatch = relicRegex.exec(relicSection)) !== null) {
                const relicName = relicMatch[1];
                const relicBody = relicMatch[2];
                
                // Skip Requiem
                if (relicName.startsWith('Requiem')) continue;
                
                // Extract fields
                const tierMatch = relicBody.match(/Tier\s*=\s*"([^"]+)"/);
                if (!tierMatch) continue;
                
                const tier = tierMatch[1];
                if (!['Lith', 'Meso', 'Neo', 'Axi'].includes(tier)) continue;
                
                const vaultedMatch = relicBody.match(/Vaulted\s*=\s*"([^"]+)"/);
                const introducedMatch = relicBody.match(/Introduced\s*=\s*"([^"]+)"/);
                
                // Extract drops
                const dropsMatch = relicBody.match(/Drops\s*=\s*\{([\s\S]*?)\n\t\t\}/);
                const drops = [];
                
                if (dropsMatch) {
                    const dropsContent = dropsMatch[1];
                    const dropRegex = /\{\s*Item\s*=\s*"([^"]+)"[^}]*Part\s*=\s*"([^"]*)"[^}]*Rarity\s*=\s*"([^"]+)"[^}]*\}/g;
                    let dropMatch;
                    
                    while ((dropMatch = dropRegex.exec(dropsContent)) !== null) {
                        drops.push({
                            Item: dropMatch[1],
                            Part: dropMatch[2],
                            Rarity: dropMatch[3]
                        });
                    }
                }
                
                relicDatabase[relicName] = {
                    Name: relicName,
                    Tier: tier,
                    Introduced: introducedMatch ? introducedMatch[1] : '',
                    Vaulted: vaultedMatch ? vaultedMatch[1] : null,
                    Drops: drops
                };
                
                // Aggiungi al database degli item
                drops.forEach(drop => {
                    const itemKey = `${drop.Item}${drop.Part ? ' - ' + drop.Part : ''}`;
                    if (!itemDatabase[itemKey]) {
                        itemDatabase[itemKey] = [];
                    }
                    itemDatabase[itemKey].push({
                        relicName: relicName,
                        rarity: drop.Rarity,
                        vaulted: vaultedMatch ? vaultedMatch[1] : null
                    });
                });
                
                if (vaultedMatch) {
                    vaultedRelics.push(relicName);
                } else {
                    activeRelics.push(relicName);
                }
                
                count++;
            }
            
        }

        function performSearch() {
            const input = document.getElementById('searchInput').value.trim();
            const resultDiv = document.getElementById('result');
            
            if (!input) {
                resultDiv.innerHTML = '<div class="error">Enter a relic name or item</div>';
                return;
            }
            
            // Check if database is loaded
            if (Object.keys(relicDatabase).length === 0) {
                resultDiv.innerHTML = '<div class="error">Please wait for database loading...</div>';
                return;
            }
            
            // Se l'input contiene " - " è probabilmente un item (es: "Nova Prime - Blueprint")
            // Cerca prima negli item
            if (input.includes(' - ')) {
                searchItem(input);
                return;
            }
            
            // Cerca prima nelle reliquie
            let relicKey = Object.keys(relicDatabase).find(key => 
                key.toLowerCase() === input.toLowerCase()
            );
            
            if (!relicKey) {
                relicKey = Object.keys(relicDatabase).find(key => 
                    key.toLowerCase().includes(input.toLowerCase())
                );
            }
            
            // Se trovata una reliquia, mostrala
            if (relicKey) {
                const relic = relicDatabase[relicKey];
                displayRelicDetails(relic);
                return;
            }
            
            // Altrimenti cerca negli item
            searchItem(input);
        }
        
        function searchRelic() {
            performSearch();
        }
        
        function searchItem(input) {
            const resultDiv = document.getElementById('result');
            const inputLower = input.toLowerCase();
            
            // Cerca item che contengono la stringa
            const matchingItems = Object.keys(itemDatabase).filter(item => 
                item.toLowerCase().includes(inputLower)
            );
            
            if (matchingItems.length === 0) {
                resultDiv.innerHTML = `<div class="error">Relic or item "${input}" not found</div>`;
                return;
            }
            
            // Se c'è un match esatto, usa quello, altrimenti usa il primo match
            let selectedItem = matchingItems.find(item => 
                item.toLowerCase() === inputLower
            ) || matchingItems[0];
            
            displayItemDetails(selectedItem);
        }
        
        // Funzione per convertire il nome dell'item in slug per l'API di Warframe Market
        function itemNameToSlug(itemName) {
            // Rimuovi spazi extra e converti in lowercase
            let slug = itemName.trim().toLowerCase();
            
            // Controlla se è una reliquia (inizia con Lith, Meso, Neo, Axi)
            const isRelic = /^(lith|meso|neo|axi)\s+/i.test(itemName);
            
            // Gestisci le parti comuni (es: "Ash - Blueprint" -> "ash_blueprint")
            slug = slug
                .replace(/\s*-\s*/g, '_')  // Sostituisci " - " con "_"
                .replace(/\s+/g, '_')       // Sostituisci spazi con underscore
                .replace(/['']/g, '')       // Rimuovi apostrofi
                .replace(/[^a-z0-9_-]/g, ''); // Rimuovi caratteri speciali
            
            // Aggiungi "_relic" alla fine se è una reliquia
            if (isRelic) {
                slug += '_relic';
            }
            
            return slug;
        }
        
        // Funzione per recuperare il prezzo più basso dall'API di Warframe Market
        async function getLowestPrice(itemName) {
            try {
                const slug = itemNameToSlug(itemName);
                console.log(`Cercando prezzo per: ${itemName} -> slug: ${slug}`);
                
                // Usa un proxy CORS per bypassare le restrizioni CORS
                const proxyUrl = 'https://corsproxy.io/?';
                const apiUrl = `https://api.warframe.market/v2/orders/item/${slug}/top`;
                
                const response = await fetch(proxyUrl + encodeURIComponent(apiUrl), {
                    headers: {
                        'Platform': 'pc'
                    }
                });
                
                console.log(`Response status: ${response.status} per ${slug}`);
                
                if (!response.ok) {
                    console.log(`Errore HTTP ${response.status} per ${slug}`);
                    return null;
                }
                
                const data = await response.json();
                console.log(`Dati ricevuti per ${slug}:`, data);
                
                // Ottieni l'ordine di vendita con il prezzo più basso
                if (data.data && data.data.sell && data.data.sell.length > 0) {
                    const lowestSellOrder = data.data.sell[0];
                    console.log(`Prezzo trovato per ${slug}: ${lowestSellOrder.platinum}`);
                    return { price: lowestSellOrder.platinum, found: true };
                }
                
                // L'item esiste ma non ci sono venditori online
                if (data.data && data.data.sell) {
                    console.log(`Nessun venditore online per ${slug}`);
                    return { price: null, found: true, noSellers: true };
                }
                
                console.log(`Item non trovato per ${slug}`);
                return { price: null, found: false };
            } catch (error) {
                console.error('Errore nel recupero del prezzo:', error);
                return { price: null, found: false };
            }
        }
        
        // Funzione per verificare se un item è tradabile su Warframe Market
        function isTradableItem(itemName) {
            const nonTradableItems = [
                'forma',
                'orokin cell',
                'neurode',
                'neural sensor',
                'control module',
                'morphic',
                'gallium',
                'plastid',
                'polymer bundle',
                'salvage',
                'ferrite',
                'nano spore',
                'alloy plate',
                'circuits',
                'rubedo',
                'argon crystal'
            ];
            
            const lowerName = itemName.toLowerCase();
            
            // Controlla se l'item è nella lista dei non tradabili
            if (nonTradableItems.some(item => lowerName.includes(item))) {
                return false;
            }
            
            return true;
        }

        async function displayItemDetails(itemName) {
            const resultDiv = document.getElementById('result');
            const relics = itemDatabase[itemName];
            
            // Carica l'immagine blueprint per gli item
            if (window.loadBlueprintImage) {
                window.loadBlueprintImage('blueprint.jpg');
            }
            
            // Controlla se c'è almeno una reliquia attiva
            const hasActiveRelic = relics.some(r => !r.vaulted);
            const itemStatus = hasActiveRelic 
                ? `<span class="active">ACTIVE</span>`
                : `<span class="vaulted">VAULTED</span>`;
            
            // Verifica se l'item è tradabile
            const tradable = isTradableItem(itemName);
            
            // Mostra prima i dettagli con un indicatore di caricamento per il prezzo (solo se tradabile)
            let html = `
                <div class="result">
                    <h2>${itemName}</h2>
                    <p><strong>Status:</strong> ${itemStatus}</p>
                    ${tradable ? '<p id="price-container"><strong>Lowest Market Price:</strong> <span class="price-loading">Loading...</span></p>' : ''}
                    <div class="relic-details">
                        <h3>Found in relics:</h3>
                        <ul class="drop-list">
            `;
            
            // Ordina le reliquie per tier e poi per nome
            const sortedRelics = [...relics].sort((a, b) => {
                const tierOrder = { 'Lith': 1, 'Meso': 2, 'Neo': 3, 'Axi': 4 };
                const tierA = relicDatabase[a.relicName]?.Tier || '';
                const tierB = relicDatabase[b.relicName]?.Tier || '';
                
                if (tierOrder[tierA] !== tierOrder[tierB]) {
                    return tierOrder[tierA] - tierOrder[tierB];
                }
                
                return a.relicName.localeCompare(b.relicName);
            });
            
            sortedRelics.forEach(relicInfo => {
                const rarityClass = relicInfo.rarity.toLowerCase();
                const vaultStatus = relicInfo.vaulted 
                    ? `<span class="vaulted">VAULTED</span>`
                    : `<span class="active">ACTIVE</span>`;
                
                html += `
                    <li class="drop-item ${rarityClass}" onclick="selectAndSearch('${relicInfo.relicName}')">
                        <div class="item-relic-info">
                            <span class="relic-name-link">
                                ${relicInfo.relicName}
                            </span>
                            <span class="relic-rarity">(${relicInfo.rarity})</span>
                            <span class="relic-status">${vaultStatus}</span>
                        </div>
                    </li>
                `;
            });
            
            html += `
                        </ul>
                    </div>
                </div>
            `;
            
            resultDiv.innerHTML = html;
            
            // Recupera il prezzo dal mercato in modo asincrono (solo se tradabile)
            if (tradable) {
                getLowestPrice(itemName).then(result => {
                    const priceContainer = document.getElementById('price-container');
                    if (priceContainer) {
                        if (result.price !== null) {
                            const slug = itemNameToSlug(itemName);
                            const marketUrl = `https://warframe.market/items/${slug}`;
                            priceContainer.innerHTML = `<strong>Lowest Market Price:</strong> <a href="${marketUrl}" target="_blank" rel="noopener noreferrer" class="price-link"><span class="price-platinum">${result.price} <img src="Platinum.png" alt="platinum" class="platinum-icon"> platinum</span></a>`;
                        } else if (result.noSellers) {
                            const slug = itemNameToSlug(itemName);
                            const marketUrl = `https://warframe.market/items/${slug}`;
                            priceContainer.innerHTML = `<strong>Market Price:</strong> <a href="${marketUrl}" target="_blank" rel="noopener noreferrer" class="price-link"><span class="price-unavailable">No sellers online</span></a>`;
                        } else {
                            priceContainer.innerHTML = `<strong>Market Price:</strong> <span class="price-unavailable">Not available</span>`;
                        }
                    }
                });
            }
        }

        function displayRelicDetails(relic) {
            const resultDiv = document.getElementById('result');
            const status = relic.Vaulted 
                ? `<span class="vaulted">VAULTED</span> (since ${relic.Vaulted})`
                : `<span class="active">ACTIVE</span>`;
            
            // Cambia il modello 3D in base al tier della reliquia
            if (window.changeModelByTier) {
                window.changeModelByTier(relic.Tier);
            }
            
            let html = `
                <div class="result">
                    <h2>${relic.Name}</h2>
                    <p><strong>Tier:</strong> ${relic.Tier}</p>
                    <p><strong>Status:</strong> ${status}</p>
                    <p><strong>Introduced:</strong> ${relic.Introduced}</p>
                    <p id="price-container"><strong>Lowest Market Price:</strong> <span class="price-loading">Loading...</span></p>
                    
                    <div class="relic-details">
                        <div class="content-header">
                            <h3>Content:</h3>
                            <div class="help-container">
                                <span class="help-icon">?</span>
                                <div class="drop-guide-tooltip">
                                    <p><strong>Drop Chances:</strong></p>
                                    <div class="refinement-section">
                                        <p class="refinement-title">Intact:</p>
                                        <p>Common: 25.33% | Uncommon: 11% | Rare: 2%</p>
                                    </div>
                                    <div class="refinement-section">
                                        <p class="refinement-title">Exceptional:</p>
                                        <p>Common: 23.33% | Uncommon: 13% | Rare: 4%</p>
                                    </div>
                                    <div class="refinement-section">
                                        <p class="refinement-title">Flawless:</p>
                                        <p>Common: 20% | Uncommon: 17% | Rare: 6%</p>
                                    </div>
                                    <div class="refinement-section">
                                        <p class="refinement-title">Radiant:</p>
                                        <p>Common: 16.67% | Uncommon: 20% | Rare: 10%</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <ul class="drop-list">
            `;
            
            relic.Drops.forEach(drop => {
                const rarityClass = drop.Rarity.toLowerCase();
                const itemName = `${drop.Item}${drop.Part ? ' - ' + drop.Part : ''}`;
                
                html += `
                    <li class="drop-item ${rarityClass}" onclick="selectAndSearchItem('${itemName.replace(/'/g, "\\'")}')">
                        <span class="item-name-underline">${itemName}</span> 
                        <small>(${drop.Rarity})</small>
                    </li>
                `;
            });
            
            html += `
                        </ul>
                    </div>
                </div>
            `;
            
            resultDiv.innerHTML = html;
            
            // Recupera il prezzo dal mercato in modo asincrono
            getLowestPrice(relic.Name).then(result => {
                const priceContainer = document.getElementById('price-container');
                if (priceContainer) {
                    if (result.price !== null) {
                        const slug = itemNameToSlug(relic.Name);
                        const marketUrl = `https://warframe.market/items/${slug}`;
                        priceContainer.innerHTML = `<strong>Lowest Market Price:</strong> <a href="${marketUrl}" target="_blank" rel="noopener noreferrer" class="price-link"><span class="price-platinum">${result.price} <img src="Platinum.png" alt="platinum" class="platinum-icon"> platinum</span></a>`;
                    } else if (result.noSellers) {
                        const slug = itemNameToSlug(relic.Name);
                        const marketUrl = `https://warframe.market/items/${slug}`;
                        priceContainer.innerHTML = `<strong>Market Price:</strong> <a href="${marketUrl}" target="_blank" rel="noopener noreferrer" class="price-link"><span class="price-unavailable">No sellers online</span></a>`;
                    } else {
                        priceContainer.innerHTML = `<strong>Market Price:</strong> <span class="price-unavailable">Not available</span>`;
                    }
                }
            });
        }

        function displayActiveRelics() {
            const listDiv = document.getElementById('activeRelicsList');
            const relicsToShow = currentRelicsView === 'active' ? activeRelics : vaultedRelics;
            
            if (relicsToShow.length === 0) {
                listDiv.innerHTML = '<p style="color: #999;">Loading...</p>';
                return;
            }
            
            let html = '<div class="relic-list">';
            relicsToShow.forEach(relicName => {
                html += `<div class="relic-name" onclick="selectAndSearch('${relicName}')">${relicName}</div>`;
            });
            html += '</div>';
            
            listDiv.innerHTML = html;
        }
        
        function toggleRelicsView(view) {
            currentRelicsView = view;
            
            // Aggiorna i pulsanti
            document.getElementById('activeRelicsBtn').classList.toggle('active', view === 'active');
            document.getElementById('vaultedRelicsBtn').classList.toggle('active', view === 'vaulted');
            
            // Aggiorna la lista
            displayActiveRelics();
        }

        function selectAndSearch(relicName) {
            document.getElementById('searchInput').value = relicName;
            searchRelic();
        }
        
        function selectAndSearchItem(itemName) {
            document.getElementById('searchInput').value = itemName;
            performSearch();
        }

        // Autocomplete
        document.getElementById('searchInput').addEventListener('input', (e) => {
            const value = e.target.value.toLowerCase();
            const suggestionsDiv = document.getElementById('suggestions');
            
            if (value.length < 2) {
                suggestionsDiv.style.display = 'none';
                return;
            }
            
            // Cerca sia nelle reliquie che negli item
            const relicMatches = Object.keys(relicDatabase)
                .filter(name => name.toLowerCase().includes(value))
                .slice(0, 5)
                .map(name => {
                    const relic = relicDatabase[name];
                    const status = relic.Vaulted ? 'vaulted' : 'active';
                    return { name, type: 'relic', status };
                });
            
            const itemMatches = Object.keys(itemDatabase)
                .filter(name => name.toLowerCase().includes(value))
                .slice(0, 5)
                .map(name => {
                    const hasActiveRelic = itemDatabase[name].some(r => !r.vaulted);
                    const status = hasActiveRelic ? 'active' : 'vaulted';
                    return { name, type: 'item', status };
                });
            
            const matches = [...relicMatches, ...itemMatches].slice(0, 10);
            
            if (matches.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }
            
            suggestionsDiv.innerHTML = matches
                .map(match => {
                    const statusBadge = `<span class="${match.status}">${match.status.toUpperCase()}</span>`;
                    return `<div class="suggestion-item" onclick="selectSuggestion('${match.name.replace(/'/g, "\\'")}')"><span class="suggestion-name">${match.name}</span> ${statusBadge}</div>`;
                })
                .join('');
            suggestionsDiv.style.display = 'block';
        });

        function selectRelic(name) {
            document.getElementById('searchInput').value = name;
            document.getElementById('suggestions').style.display = 'none';
            performSearch();
        }
        
        function selectSuggestion(name) {
            document.getElementById('searchInput').value = name;
            document.getElementById('suggestions').style.display = 'none';
            performSearch();
        }

        // Close suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-box')) {
                document.getElementById('suggestions').style.display = 'none';
            }
        });

        // Press Enter to search
        document.getElementById('searchInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });

        // Posizionamento dinamico del tooltip drop chances
        document.addEventListener('mouseover', (e) => {
            const helpIcon = e.target.closest('.help-icon');
            if (helpIcon) {
                const tooltip = helpIcon.nextElementSibling;
                if (tooltip && tooltip.classList.contains('drop-guide-tooltip')) {
                    const rect = helpIcon.getBoundingClientRect();
                    tooltip.style.left = rect.left + 'px';
                    tooltip.style.top = (rect.bottom + 5) + 'px';
                }
            }
        });
    </script>
</body>
</html>
